[{"name":"app.R","content":"\r\n\r\n\r\nsource(\"init.R\")\r\n\r\nshinyApp()\r\n","type":"text"},{"name":"server.R","content":"library(ggplot2)\r\nlibrary(plotly)\r\nlibrary(dplyr)\r\nlibrary(shiny)\r\nlibrary(tidyr)\r\nlibrary(shinyjs)\r\nsource(\"utils.R\") \r\nsource(\"Labeling _duration_bounds.R\")\r\n\r\n\r\n# Define server logic \r\nserver <- function(input, output, session) {\r\n \r\n   observe({\r\n    # Code to execute on page load\r\n    cat(\"App has loaded!\\n\")\r\n    runjs('$(document).ready(function() {$(\"#page1_submit\").click();});')\r\n    runjs('$(document).ready(function() {$(\"#page2_submit\").click();});')\r\n    \r\n  })\r\n  \r\n  #====================================================\r\n  #page 1\r\n  #====================================================\r\n  \r\n  page1_inputdata <- reactive({\r\n    dict <- data.frame(\r\n      key = c(\"bwe\", \"time\", \"peptide\", \"neh\", \"k\", \"delta_I0\", \"kt\"),\r\n      value = c(\r\n        input$page1_bwe,\r\n        input$page1_maxTime,\r\n        input$page1_peptide,\r\n        getNeh(input$page1_peptide),\r\n        input$page1_expected_k,\r\n        input$page1_delta_I0,\r\n        solve_for_kt_vals(input$page1_max_error / 100)\r\n      )\r\n    )\r\n    output <- dict\r\n  })\r\n  \r\n  \r\n  output$page1_plot <- renderText(if (input$page1_submit > 0)\r\n  {\r\n    temp = isolate(page1_inputdata())\r\n    \r\n    if (temp$value[temp$key == \"kt\"] == Inf) {\r\n      return (\r\n        \"Unable to determine the labeling durations for the given inputs. Please adjust the input parameters.\"\r\n      )\r\n    }\r\n    else{\r\n      return (paste(c(\r\n        paste(c(\r\n          \"Peptide: \", temp$value[temp$key == \"peptide\"], \"(NEH\", (temp$value[temp$key == \"neh\"]), \")\"\r\n        )), paste(c(\" Max. Days: \", temp$value[temp$key == \"time\"])), paste(c(\r\n          \" kt: \", sprintf(\"%.4f\", as.numeric(temp$value[temp$key == \"kt\"]))\r\n        )), paste(c(\" BWE: \", temp$value[temp$key == \"bwe\"]))\r\n      )\r\n      , sep = \",\"))\r\n    }\r\n  }\r\n  else{\r\n    return (\"Server is ready for calculation.\")\r\n  })\r\n  \r\n  \r\n  \r\n  simulateGetLowerAndUpperLimits <- reactive({\r\n    temp_input = (page1_inputdata())\r\n    temp_res = getLowerAndUpperLimits(\r\n      as.numeric(temp_input$value[temp_input$key == \"neh\"]),\r\n      as.numeric(temp_input$value[temp_input$key == \"bwe\"]),\r\n      as.numeric(temp_input$value[temp_input$key == \"time\"]),\r\n      as.numeric(temp_input$value[temp_input$key == \"k\"]),\r\n      (temp_input$value[temp_input$key == \"peptide\"]),\r\n      as.numeric(temp_input$value[temp_input$key == \"delta_I0\"]),\r\n      as.numeric(temp_input$value[temp_input$key == \"kt\"])\r\n    )\r\n    \r\n    output <- temp_res\r\n  })\r\n  \r\n  \r\n  output$page1_summaryTable <- renderTable ({\r\n    if (input$page1_submit > 0)\r\n    {\r\n      temp_res = isolate(simulateGetLowerAndUpperLimits())\r\n      \r\n      temp_res %>%\r\n        rename(\r\n          \"Labeling Duration\" =    \"time\",\r\n          \"Lower Limit (theo.)\" =  \"theo_lb_values\",\r\n          \"Upper Limit (theo.)\" =   \"theo_ub_values\",\r\n          \"Lower Limit (exp.)\" =   \"lb\",\r\n          \"Upper Limit (exp.)\" =   \"ub\",\r\n          \"In Range\" =              \"InRange\"\r\n        )\r\n      \r\n      \r\n      \r\n      \r\n    }\r\n  })\r\n  \r\n  \r\n  \r\n  output$page1_plot <- renderPlotly(if (input$page1_submit > 0)\r\n  {\r\n    temp_res = isolate(simulateGetLowerAndUpperLimits()) \r\n    \r\n    temp_plot = getPossibleRangePlot_plotly(temp_res) \r\n    \r\n    ggplotly(temp_plot)\r\n  })\r\n  \r\n  output$page1_recommendation <- renderText(if (input$page1_submit > 0)\r\n  {\r\n    temp_res = isolate(simulateGetLowerAndUpperLimits())\r\n    possibleRange <- temp_res %>% filter(InRange == TRUE)\r\n    min_time <- min(possibleRange$time)\r\n    max_time <- max(possibleRange$time)\r\n    \r\n    return (paste(\r\n      c(\r\n        \"Minimum Labeling Duration\",\r\n        min_time,\r\n        \"\\nMaximum Labeling Duration\",\r\n        max_time\r\n      )\r\n    ))\r\n  }\r\n  else{\r\n    return (\"\")\r\n  })\r\n  \r\n  \r\n  #====================================================\r\n  #====================================================\r\n  #page 2\r\n  \r\n  \r\n  page2_inputdata <- reactive({\r\n    dict <- data.frame(\r\n      key = c(\r\n        \"bwe\",\r\n        \"time\",\r\n        \"peptide\",\r\n        \"neh\",\r\n        \"k_low\",\r\n        \"k_high\",\r\n        \"delta_I0\",\r\n        \"kt\"\r\n      ),\r\n      value = c(\r\n        input$page2_bwe,\r\n        input$page2_maxTime,\r\n        input$page2_peptide,\r\n        getNeh(input$page2_peptide),\r\n        input$page2_expected_k_low,\r\n        input$page2_expected_k_high,\r\n        input$page2_delta_I0,\r\n        solve_for_kt_vals(input$page2_max_error / 100)\r\n      )\r\n    )\r\n    output <- dict\r\n  })\r\n  \r\n  \r\n  output$simstatus_3 <- renderText(if (input$page2_submit > 0)\r\n  {\r\n    temp = isolate(page2_inputdata())\r\n    \r\n    \r\n    return (paste(c(paste(\r\n      c(\"Peptide: \", temp$value[temp$key == \"peptide\"], \"(NEH\", (temp$value[temp$key == \"neh\"]), \")\")\r\n    ), paste(\r\n      c(\" Max. Days: \", temp$value[temp$key == \"time\"])\r\n    ), paste(c(\r\n      \" kt: \", sprintf(\"%.4f\", as.numeric(temp$value[temp$key == \"kt\"]))\r\n    )), paste(\r\n      c(\" BWE: \", temp$value[temp$key == \"bwe\"])\r\n    ))\r\n    , sep = \",\"))\r\n  }\r\n  else{\r\n    return (\"Server is ready for calculation.\")\r\n  })\r\n  \r\n  \r\n  \r\n  simulateGetLowerAndUpperLimits_3 <- reactive({\r\n    temp_input = (page2_inputdata())\r\n    temp_res = getLowerAndUpperLimits_Range(\r\n      as.numeric(temp_input$value[temp_input$key == \"neh\"]),\r\n      as.numeric(temp_input$value[temp_input$key == \"bwe\"]),\r\n      as.numeric(temp_input$value[temp_input$key == \"time\"]),\r\n      as.numeric(temp_input$value[temp_input$key == \"k_low\"]),\r\n      as.numeric(temp_input$value[temp_input$key == \"k_high\"]),\r\n      (temp_input$value[temp_input$key == \"peptide\"]),\r\n      as.numeric(temp_input$value[temp_input$key == \"delta_I0\"]),\r\n      as.numeric(temp_input$value[temp_input$key == \"kt\"])\r\n    )\r\n    \r\n    # print((temp_res))\r\n    \r\n    output <- temp_res\r\n  })\r\n  \r\n  \r\n  output$simdatatable_3 <- renderTable ({\r\n    if (input$page2_submit > 0)\r\n    {\r\n      temp_input = isolate(page2_inputdata())\r\n      temp_res = isolate(simulateGetLowerAndUpperLimits_3())\r\n      \r\n      temp_res %>%\r\n        mutate(across(where(is.numeric), ~ format(\r\n          .x, digits = 5, nsmall = 5\r\n        )))\r\n      \r\n      print(temp_res)\r\n      \r\n      # colname_lb_low = paste(\"Lower Limit (exp.), k=\", as.numeric(temp_input$value[temp_input$key == \"k_low\"]))\r\n      # colname_ub_low = paste(\"Upper Limit (exp.), k=\", as.numeric(temp_input$value[temp_input$key == \"k_low\"]))\r\n      # colname_exp_lb_high = paste(\"Lower Limit (exp.), k=\", as.numeric(temp_input$value[temp_input$key == \"k_high\"]))\r\n      # colname_exp_ub_high = paste(\"Upper Limit (exp.), k=\", as.numeric(temp_input$value[temp_input$key == \"k_high\"]))\r\n      # colname_InRange_low = paste(\"In Range, k=\", as.numeric(temp_input$value[temp_input$key == \"k_low\"]))\r\n      # colname_InRange_upper =      paste(\"In Range, k=\", as.numeric(temp_input$value[temp_input$key == \"k_high\"]))\r\n      \r\n      colname_ub_low = paste(\"Upper Limit (exp.), k=\", as.numeric(temp_input$value[temp_input$key == \"I0_t_low_k\"]))\r\n      colname_exp_lb_high = paste(\"Lower Limit (exp.), k=\", as.numeric(temp_input$value[temp_input$key == \"I0_t_high_k\"]))\r\n      colname_InRange_low = paste(\"In Range, k=\", as.numeric(temp_input$value[temp_input$key == \"k_low\"]))\r\n      colname_InRange_upper =      paste(\"In Range, k=\", as.numeric(temp_input$value[temp_input$key == \"k_high\"]))\r\n      \r\n      # temp_res <- temp_res %>%\r\n      #   rename_with(\r\n      #     ~ case_when(\r\n      #       . == \"time\" ~ \"Labeling Duration\",\r\n      #       . == \"theo_lb_values\" ~ \"Lower Limit (theo.)\",\r\n      #       . == \"theo_ub_values\" ~ \"Upper Limit (theo.)\",\r\n      #       . == \"lb_low\" ~ colname_lb_low,\r\n      #       . == \"ub_low\" ~ colname_ub_low,\r\n      #       . == \"exp_lb_high\" ~ colname_exp_lb_high,\r\n      #       . == \"exp_ub_high\" ~ colname_exp_ub_high,\r\n      #       . == \"InRange_low\" ~ colname_InRange_low,\r\n      #       . == \"InRange_upper\" ~ colname_InRange_upper,\r\n      #       TRUE ~ .\r\n      #     )\r\n      #   )\r\n      \r\n      temp_res <- temp_res %>%\r\n        rename_with(\r\n          ~ case_when(\r\n            . == \"time\" ~ \"Labeling Duration\",\r\n            . == \"theo_lb_values\" ~ \"Lower Limit (theo.)\",\r\n            . == \"theo_ub_values\" ~ \"Upper Limit (theo.)\", \r\n            . == \"ub_low\" ~ colname_ub_low, \r\n            . == \"exp_ub_high\" ~ colname_exp_lb_high,\r\n            . == \"InRange_low\" ~ colname_InRange_low,\r\n            . == \"InRange_upper\" ~ colname_InRange_upper,\r\n            TRUE ~ .\r\n          )\r\n        )\r\n      \r\n      print(\"---------------------\")\r\n      print(temp_res)\r\n      \r\n    }\r\n  })\r\n  \r\n  \r\n  \r\n  output$simplot_3 <- renderPlotly(if (input$page2_submit > 0)\r\n  {\r\n    temp_res = isolate(simulateGetLowerAndUpperLimits_3())\r\n    \r\n    \r\n    temp_input = isolate(page2_inputdata())\r\n    \r\n    temp_plot = getPossibleRangePlot_plotly_range(temp_res,\r\n                                                  as.numeric(temp_input$value[temp_input$key == \"k_low\"]),\r\n                                                  as.numeric(temp_input$value[temp_input$key == \"k_high\"]))\r\n    \r\n    \r\n    ggplotly(temp_plot)\r\n  })\r\n  \r\n  \r\n  \r\n  output$simstatus_recommendation_3 <- renderText(if (input$page2_submit > 0)\r\n  {\r\n    temp_res = isolate(simulateGetLowerAndUpperLimits_3())\r\n    possibleRange <- temp_res %>% filter(InRange_low == TRUE &\r\n                                           InRange_upper == TRUE)\r\n    min_time <- min(possibleRange$time)\r\n    max_time <- max(possibleRange$time)\r\n    \r\n    return (paste(\r\n      c(\r\n        \"Minimum Labeling Duration\",\r\n        min_time,\r\n        \"\\nMaximum Labeling Duration\",\r\n        max_time\r\n      )\r\n    ))\r\n  }\r\n  else{\r\n    return (\"\")\r\n  })\r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n}\r\n","type":"text"},{"name":"ui.R","content":"library(ggplot2)\r\nlibrary(plotly)\r\nlibrary(bslib)\r\nlibrary(shiny)\r\nlibrary(shinythemes)\r\n\r\nlibrary(shinyjs)\r\n\r\n# Define UI for application that draws a histogram\r\nui <- fluidPage(\r\n  theme = shinytheme(\"cosmo\"),\r\n  useShinyjs(),\r\n  #cosmo\r\n  navbarPage(\r\n    \"Turnover rate estimation\",\r\n    #==================================================\r\n    #==================== labeling duraiton============\r\n    tabPanel(\r\n      \"Labeling duration estimation\",\r\n      sidebarLayout(\r\n        sidebarPanel(\r\n          textInput('page1_peptide', label = \"Peptide\", value = \"VGAFTVVCK\"),\r\n          numericInput(\r\n            \"page1_expected_k\",\r\n            label = \"Expected turnover rate\",\r\n            min = 0.00,\r\n            max = 0.9,\r\n            value = 0.05,\r\n            step = 0.01\r\n          ),\r\n          numericInput(\r\n            \"page1_bwe\",\r\n            label = \"Body water Enrichment\",\r\n            min = 0.01,\r\n            max = 0.9,\r\n            value = 0.046,\r\n            step = 0.01\r\n          ),\r\n          numericInput(\r\n            \"page1_delta_I0\",\r\n            label = (HTML(paste0(\"∆I\", tags$sub(\r\n              \"0\"\r\n            )))),\r\n            min = 0.01,\r\n            max = 0.9,\r\n            value = 0.031,\r\n            step = 0.01\r\n          ),\r\n          numericInput(\r\n            \"page1_max_error\",\r\n            label = \"Maximum k relative error (%)\",\r\n            min = 0,\r\n            max = 100,\r\n            value = 25,\r\n            step = 0.5\r\n          ),\r\n          sliderInput(\r\n            \"page1_maxTime\",\r\n            \"Max. Labeling Duration\",\r\n            min = 1,\r\n            max = 100,\r\n            value = 24\r\n          ),\r\n          \r\n          actionButton(\"page1_submit\", \"Submit\", class = \"btn  btn-danger\")\r\n        ),\r\n        mainPanel(\r\n          verbatimTextOutput(\"page1_status\"),\r\n          # Output: A tabset that combines three panels ----\r\n          navset_tab(\r\n            # title = \"Visualizations\",\r\n            # Panel with plot ----\r\n            nav_panel(\"Plot\", plotlyOutput(\"page1_plot\")),\r\n            \r\n            # Panel with summary ----\r\n            nav_panel(\"Summary\", tableOutput(\"page1_summaryTable\")),\r\n             \r\n          ),\r\n          \r\n          tags$p(\r\n            \"Remark: The labeling duration should be set so that I0(t) is between the theoretical upper bound (red line) and the lower bound (black line).\"\r\n          ),\r\n          verbatimTextOutput(\"page1_recommendation\"),\r\n          \r\n        )\r\n      )\r\n    ),\r\n    \r\n    \r\n    #==================================================\r\n    #==================== labeling  Range============\r\n    tabPanel(\r\n      \"Labeling duration estimation [Range]\",\r\n      sidebarLayout(\r\n        sidebarPanel(\r\n          textInput('page2_peptide', label = \"Peptide\", value = \"AQTAHIVLEDGTK\"),\r\n          numericInput(\r\n            \"page2_expected_k_low\",\r\n            label = \"Expected slowest turnover rate\",\r\n            min = 0.00,\r\n            max = 0.9,\r\n            value = 0.06,\r\n            step = 0.01\r\n          ),\r\n          numericInput(\r\n            \"page2_expected_k_high\",\r\n            label = \"Expected highest turnover rate\",\r\n            min = 0.00,\r\n            max = 0.9,\r\n            value = 0.12,\r\n            step = 0.01\r\n          ),\r\n          numericInput(\r\n            \"page2_bwe\",\r\n            label = \"Body water Enrichment\",\r\n            min = 0.01,\r\n            max = 0.9,\r\n            value = 0.046,\r\n            step = 0.01\r\n          ),\r\n          numericInput(\r\n            \"page2_delta_I0\",\r\n            label = (HTML(paste0(\"∆I\", tags$sub(\r\n              \"0\"\r\n            )))),\r\n            min = 0.01,\r\n            max = 0.9,\r\n            value = 0.031,\r\n            step = 0.01\r\n          ),\r\n          numericInput(\r\n            \"page2_max_error\",\r\n            label = \"Maximum relative error (%)\",\r\n            min = 0,\r\n            max = 100,\r\n            value = 25,\r\n            step = 0.5\r\n          ),\r\n          sliderInput(\r\n            \"page2_maxTime\",\r\n            \"Max. Labeling Duration\",\r\n            min = 1,\r\n            max = 100,\r\n            value = 24\r\n          ),\r\n          \r\n          actionButton(\"page2_submit\", \"Submit\", class = \"btn  btn-info\")\r\n        ),\r\n        mainPanel(\r\n          verbatimTextOutput(\"simstatus_3\"),\r\n          # plotlyOutput(\"simplot\"),\r\n          # h3(\"\"),\r\n          # tableOutput(\"simdatatable\")\r\n          \r\n          # Output: A tabset that combines three panels ----\r\n          navset_tab(\r\n            # title = \"Visualizations\",\r\n            # Panel with plot ----\r\n            nav_panel(\"Plot\", plotlyOutput(\"simplot_3\")),\r\n            \r\n            # Panel with summary ----\r\n            nav_panel(\"Summary\", tableOutput(\"simdatatable_3\")),\r\n            \r\n            # # Panel with table ----\r\n            # nav_panel(\"Table\", tableOutput(\"table\"))\r\n          ),\r\n          \r\n          tags$p(\r\n            \"Remark: The labeling duration should be set so that I0(t) is between the theoretical upper bound (red line) and the lower bound (black line).\"\r\n          ),\r\n          verbatimTextOutput(\"simstatus_recommendation_3\"),\r\n          \r\n        )\r\n      )\r\n    ),\r\n    \r\n    #==================================================\r\n    \r\n  )\r\n)\r\n","type":"text"},{"name":"Isotopes.R","content":"#\r\n#\r\n#\r\n#   A method to compute isotope distribution of a \r\n#   peptide sequence given its amino acid sequence:\r\n#   Elemental composition - maximum of 30 amino acids,\r\n#   and maximum of 10 element types (C,H,N,O,S, X) for each element.\r\n#\r\n#    #1 Carbon, #2 Hydrogen, #3 Nitrogen, #4 Oxygen, #5 Sulfur\r\n#\r\n\r\n\r\nLetter2num <- function(Letter)\r\n{\r\n\tutf8ToInt(Letter) - utf8ToInt(\"A\") + 1L\r\n}\r\n\r\n\r\nElementalComposition <- function(Sequence)\r\n{\r\n\r\n\r\n    szPeptide = as.character(Sequence);\r\n\r\n\r\n    #print(c(\"seq = \", szPeptide));\r\n\r\n    ElementalMatrix = matrix(0, nrow = 30, ncol=5);\r\n\r\n\r\n    k = Letter2num(\"A\");   \r\n\r\n    ElementalMatrix[k, 1]  = 3;  ElementalMatrix[k, 2]  = 5;  ElementalMatrix[k, 3]  = 1;  ElementalMatrix[k, 4]  = 1;\r\n\r\n    k = Letter2num(\"G\");\r\n\r\n    ElementalMatrix[k, 1]  = 2;  ElementalMatrix[k, 2]  = 3;  ElementalMatrix[k, 3]  = 1;  ElementalMatrix[k, 4]  = 1;\r\n\r\n    k = Letter2num(\"S\");\r\n\r\n    ElementalMatrix[k, 1]  = 3;  ElementalMatrix[k, 2]  = 5;  ElementalMatrix[k, 3]  = 1;  ElementalMatrix[k, 4]  = 2;\r\n\r\n    k = Letter2num(\"P\");\r\n\r\n    ElementalMatrix[k, 1]  = 5;  ElementalMatrix[k, 2]  = 7;  ElementalMatrix[k, 3]  = 1;  ElementalMatrix[k, 4]  = 1;\r\n\r\n\r\n    k = Letter2num(\"V\");\r\n\r\n    ElementalMatrix[k, 1]  = 5;  ElementalMatrix[k, 2]  = 9;  ElementalMatrix[k, 3]  = 1;  ElementalMatrix[k, 4]  = 1;\r\n\r\n\r\n    k = Letter2num(\"T\");\r\n\r\n    ElementalMatrix[k, 1]  = 4;  ElementalMatrix[k, 2]  = 7;  ElementalMatrix[k, 3]  = 1;  ElementalMatrix[k, 4]  = 2;\r\n\r\n\r\n    k = Letter2num(\"C\");\r\n\r\n    ElementalMatrix[k, 1]  = 3;  ElementalMatrix[k, 2]  = 5;  ElementalMatrix[k, 3]  = 1;  ElementalMatrix[k, 4]  = 1;\r\n    ElementalMatrix[k, 5]  = 1;\r\n\r\n\r\n    k = Letter2num(\"L\");\r\n\r\n    ElementalMatrix[k, 1]  = 6;  ElementalMatrix[k, 2]  = 11;  ElementalMatrix[k, 3]  = 1;  ElementalMatrix[k, 4]  = 1;\r\n\r\n\r\n    k = Letter2num(\"I\");\r\n\r\n    ElementalMatrix[k, 1]  = 6;  ElementalMatrix[k, 2]  = 11;  ElementalMatrix[k, 3]  = 1;  ElementalMatrix[k, 4]  = 1;\r\n\r\n\r\n    k = Letter2num(\"N\");\r\n\r\n    ElementalMatrix[k, 1]  = 4;  ElementalMatrix[k, 2]  = 6;  ElementalMatrix[k, 3]  = 2;  ElementalMatrix[k, 4]  = 2;\r\n\r\n\r\n    k = Letter2num(\"D\");\r\n\r\n    ElementalMatrix[k, 1]  = 4;  ElementalMatrix[k, 2]  = 5;  ElementalMatrix[k, 3]  = 1;  ElementalMatrix[k, 4]  = 3;\r\n\r\n\r\n    k = Letter2num(\"Q\");\r\n\r\n    ElementalMatrix[k, 1]  = 5;  ElementalMatrix[k, 2]  = 8;  ElementalMatrix[k, 3]  = 2;  ElementalMatrix[k, 4]  = 2;\r\n\r\n\r\n    k = Letter2num(\"K\");\r\n\r\n    ElementalMatrix[k, 1]  = 6;  ElementalMatrix[k, 2]  = 12;  ElementalMatrix[k, 3]  = 2;  ElementalMatrix[k, 4]  = 1;\r\n\r\n\r\n    k = Letter2num(\"E\");\r\n\r\n    ElementalMatrix[k, 1]  = 5;  ElementalMatrix[k, 2]  = 7;  ElementalMatrix[k, 3]  = 1;  ElementalMatrix[k, 4]  = 3;\r\n\r\n\r\n    k = Letter2num(\"M\");\r\n\r\n    ElementalMatrix[k, 1]  = 5;  ElementalMatrix[k, 2]  = 9;  ElementalMatrix[k, 3]  = 1;  ElementalMatrix[k, 4]  = 1;\r\n\r\n    ElementalMatrix[k, 5]  = 1;\r\n\r\n\r\n    k = Letter2num(\"H\");\r\n\r\n    ElementalMatrix[k, 1]  = 6;  ElementalMatrix[k, 2]  = 7;  ElementalMatrix[k, 3]  = 3;  ElementalMatrix[k, 4]  = 1;\r\n\r\n\r\n    k = Letter2num(\"F\");\r\n\r\n    ElementalMatrix[k, 1]  = 9;  ElementalMatrix[k, 2]  = 9;  ElementalMatrix[k, 3]  = 1;  ElementalMatrix[k, 4]  = 1;\r\n\r\n\r\n    k = Letter2num(\"R\");\r\n\r\n    ElementalMatrix[k, 1]  = 6;  ElementalMatrix[k, 2]  = 12;  ElementalMatrix[k, 3]  = 4;  ElementalMatrix[k, 4]  = 3;\r\n\r\n\r\n    k = Letter2num(\"Y\");\r\n\r\n    ElementalMatrix[k, 1]  = 9;  ElementalMatrix[k, 2]  = 9;  ElementalMatrix[k, 3]  = 1;  ElementalMatrix[k, 4]  = 2;\r\n\r\n\r\n    j = Letter2num(\"W\");\r\n\r\n    ElementalMatrix[j, 1]  = 11;  ElementalMatrix[j, 2]  = 10;  ElementalMatrix[j, 3]  = 2;  ElementalMatrix[j, 4]  = 1;\r\n\r\n\r\n\r\n    nH = nO = nC = nN = nS = 0;\r\n\r\n    nO = 1; nN = 0;\r\n\r\n    nH = 3;\r\n    \r\n\r\n    for(i in 1:nchar(szPeptide))\r\n    {\r\n\t j = Letter2num(substring(szPeptide,i,i));\r\n\r\n         nC = nC + as.numeric(ElementalMatrix[j, 1]);\r\n\r\n\t nH = nH + ElementalMatrix[j, 2];\r\n\t \r\n         nN = nN + ElementalMatrix[j, 3];\r\n\r\n\t nO = nO + ElementalMatrix[j, 4];\r\n\r\n\t nS = nS + ElementalMatrix[j, 5];\r\n    }\r\n\r\n    Composition = list ();\r\n\r\n    Composition$nC = nC;   Composition$nH = nH;\r\n    Composition$nN = nN;   Composition$nO = nO;\r\n    Composition$nS = nS;\r\n    Composition$Sequence = szPeptide;\r\n    Composition$Isotopes = Isotopes(nC, nH, nN, nO, nS);\r\n\r\n    Composition\r\n    \r\n}\r\n\r\n\r\n#\r\n#\r\n#   computes the isotope distributions given\r\n#   the number of elemental atoms\r\n#\r\n\r\nIsotopes <- function(nC, nH, nN, nO, nS)\r\n{\r\n\r\n   #print(c(nC, nH, nN, nO, nS));\r\n   \r\n   probC = seq(1:32); probH = seq(1:32); probN = seq(1:32); probO = seq(1:32); probS = seq(1:32);\r\n\r\n   for(i in 1:32)\r\n     probC[i] = probH[i] = probN[i] = probO[i] = probS[i] = 0;\r\n\r\n   pH = 0.00015574 / (0.99984426 + 0.00015574);\r\n\r\n   probC[1] = 0.988922 / (0.988922 + 0.011078); probC[2] = 0.011078 / (0.988922 + 0.011078);\r\n\r\n\r\n   probH[1] = 0.99984426 / (0.99984426 + 0.00015574); probH[2] = 0.00015574 / (0.99984426 + 0.00015574);\r\n\r\n\r\n   probN[1] = 0.996337 / (0.996337 + 0.003663); probN[2] =  0.003663 / (0.996337 + 0.003663);\r\n\r\n\r\n   probO[1] = 0.9976206 / (0.9976206 + 0.0003790 + 0.0020004); probO[2] = 0.000379 /(0.9976206 + 0.0003790 + 0.0020004);\r\n\r\n   probO[3] = 0.0020004 /(0.9976206 + 0.0003790 + 0.0020004);\r\n\r\n\r\n   probS[1] = 0.9504074 / (0.9504074 + 0.0074869 + 0.0419599 + 0.0001458); probS[2] = 0.0074869 / (0.9504074 + 0.0074869 + 0.0419599 + 0.0001458);\r\n\r\n   probS[3] = 0.0419599 / (0.9504074 + 0.0074869 + 0.0419599 + 0.0001458);\r\n\r\n   probS[5] = 0.0001458 / (0.9504074 + 0.0074869 + 0.0419599 + 0.0001458);\r\n\r\n\r\n   probTemp = probC;\r\n   \r\n   for(i in 1:(nC-1))\r\n   {\r\n\tsum_all = sum(Re(fft(fft(probC)*fft(probTemp)/length(probC), inverse=TRUE)))\r\n\r\n\tprobTemp = Re(fft(fft(probC)*fft(probTemp)/length(probC), inverse=TRUE)) / sum_all;    \r\n   }\r\n\r\n   probC = probTemp;\r\n\r\n\r\n   probTemp = probH;\r\n   \r\n   for(i in 1:(nH-1))\r\n   {\r\n\tsum_all = sum(Re(fft(fft(probH)*fft(probTemp)/length(probH), inverse=TRUE)))\r\n\r\n\tprobTemp = Re(fft(fft(probH)*fft(probTemp)/length(probH), inverse=TRUE)) / sum_all;    \r\n   }\r\n\r\n   probH = probTemp;\r\n\r\n   #print(c(probH[1:10], dbinom(0:9, nH, pH)));\r\n\r\n   probTemp = probN;\r\n   \r\n   for(i in 1:(nN-1))\r\n   {\r\n\tsum_all = sum(Re(fft(fft(probN)*fft(probTemp)/length(probN), inverse=TRUE)))\r\n\r\n\tprobTemp = Re(fft(fft(probN)*fft(probTemp)/length(probN), inverse=TRUE)) / sum_all;    \r\n   }\r\n\r\n   probN = probTemp;\r\n\r\n\r\n   probTemp = probO;\r\n   \r\n   for(i in 1:(nO-1))\r\n   {\r\n\tsum_all = sum(Re(fft(fft(probO)*fft(probTemp)/length(probO), inverse=TRUE)))\r\n\r\n\tprobTemp = Re(fft(fft(probO)*fft(probTemp)/length(probO), inverse=TRUE)) / sum_all;    \r\n   }\r\n\r\n   probO = probTemp;\r\n\r\n\r\n\r\n   probTemp = probS;\r\n\r\n   for(i in 1:(nS-1))\r\n   {\r\n\tsum_all = sum(Re(fft(fft(probS)*fft(probTemp)/length(probS), inverse=TRUE)))\r\n\r\n\tprobTemp = Re(fft(fft(probS)*fft(probTemp)/length(probS), inverse=TRUE)) / sum_all;    \r\n   }\r\n\r\n   sum_all = sum(Re(fft(fft(probC)*fft(probH)/length(probH), inverse=TRUE)))\r\n\r\n   probTemp = Re(fft(fft(probC)*fft(probH)/length(probH), inverse=TRUE)) / sum_all;\r\n\r\n\r\n   sum_all = sum(Re(fft(fft(probN)*fft(probTemp)/length(probN), inverse=TRUE)))\r\n\r\n   probTemp = Re(fft(fft(probTemp)*fft(probN)/length(probN), inverse=TRUE)) / sum_all;    \r\n\r\n\r\n   sum_all = sum(Re(fft(fft(probO)*fft(probTemp)/length(probO), inverse=TRUE)))\r\n\r\n   probTemp = Re(fft(fft(probTemp)*fft(probO)/length(probO), inverse=TRUE)) / sum_all;    \r\n\r\n\r\n   if(nS > 0)\r\n   {\r\n          sum_all = sum(Re(fft(fft(probS)*fft(probTemp)/length(probS), inverse=TRUE)))\r\n\r\n\t  probTemp = Re(fft(fft(probTemp)*fft(probS)/length(probS), inverse=TRUE)) / sum_all;    \r\n   }\r\n\r\n\r\n   probTemp\r\n}\r\n\r\n\r\n#\r\n#\r\n#     A function that computes isotope\r\n#\r\n#     distribution of a peptide sequence\r\n#     to run it:\r\n#\r\n#     Isotope_Distribution(\"FVRRRAAAAAAAR\")\r\n#\r\n#\r\n#\r\n\r\n\r\nIsotope_Distribution <- function(Sequence)\r\n{\r\n   \r\n   Elements = ElementalComposition(Sequence);\r\n\r\n   IsotopeDist = Isotopes(Elements$nC, Elements$nH, Elements$nN, Elements$nO,\r\n   \t       Elements$nS);\r\n\r\n\r\n   # plot(c(0:(length(IsotopeDist)-1)), IsotopeDist, xlim=c(0, 15), xlab=\"Isotope Numbers\", ylab=\"Relative Isotope Abundance\",\r\n   # \t\t\t\t      main=Sequence);\r\n\r\n   # print(IsotopeDist);\r\n\r\n}\r\n\r\n\r\n\r\n#\r\n#\r\n#     A function that compares the factual and predicted\r\n#\r\n#     NEH and deuterium labeling using the new formula\r\n#\r\n#     to run it:\r\n#\r\n#     Check_Pxt(\"FVRRRAAAAAAAR\", 0.0001, 30)\r\n#\r\n#     it should reproduce both: pxt  = 0.0001\r\n#\r\n#                         and:  NEH = 30;\r\n#\r\n#\r\n\r\n\r\nCheck_Pxt <- function(Sequence, pxt, NEH)\r\n{\r\n   \r\n   pH = 0.00015574 / (0.99984426 + 0.00015574);\r\n\r\n   pX = pH + pxt;\r\n\r\n   probX = rep(0, 32);\r\n\r\n   probX[1] = 1 - pX; probX[2] = pX;\r\n\r\n   # The X element with pxt enrichment\r\n\r\n   pTemp = probX;\r\n   \r\n   for(i in 1:(NEH-1))\r\n   {\r\n        sum_all = sum(Re(fft(fft(pTemp)*fft(probX)/length(probX), inverse=TRUE)))\r\n\t\r\n   \tpTemp = Re(fft(fft(pTemp)*fft(probX)/length(probX), inverse=TRUE)) / sum_all;  \r\n   }\r\n\r\n\r\n   probX = pTemp;\r\n\r\n   print(probX[1:5]);\r\n\r\n   xtemp = dbinom(0:(NEH-1), NEH, pX);\r\n\r\n   print(xtemp[1:5]);\r\n\r\n   #print(probX);\r\n\r\n   Elements = ElementalComposition(Sequence);\r\n\r\n   IsotopeDist = Isotopes(Elements$nC, (Elements$nH - NEH), Elements$nN, Elements$nO,\r\n   \t       Elements$nS);\r\n\r\n   probTemp0 = Isotopes(Elements$nC, Elements$nH, Elements$nN, Elements$nO,\r\n   \t       Elements$nS);\r\n\r\n   sum_all = sum(Re(fft(fft(probX)*fft(IsotopeDist)/length(probX), inverse=TRUE)))\r\n\r\n   probTemp = Re(fft(fft(probX)*fft(IsotopeDist)/length(probX), inverse=TRUE)) / sum_all;  \r\n   \r\n\r\n   temp = (1 - pH)^2;\r\n\r\n   #temp = temp * (probTemp[2]/probTemp[1] - probTemp0[2]/probTemp0[1]);\r\n\r\n   #pxt_Computed = temp / (NEH + (1 - pH)*(probTemp[2]/probTemp[1] - probTemp0[2]/probTemp0[1]))\r\n\r\n   temp = temp * (probTemp[2]*probTemp0[1] - probTemp0[2]*probTemp[1]);\r\n\r\n   pxt_Computed = temp / (NEH*probTemp0[1]*probTemp[1] + (1 - pH)*(probTemp[2]*probTemp0[1] - probTemp0[2]*probTemp[1]))\r\n\r\n   NEH_Computed = (1 - pH - pxt_Computed)*(probTemp[2]/probTemp[1] - probTemp0[2]/probTemp0[1])*(1 - pH)/pxt_Computed;\r\n\r\n   print(c(pxt, pxt_Computed));\r\n\r\n   print(c(NEH, NEH_Computed));\r\n\r\n   print(c(probTemp[1:4], probTemp0[1:4]));\r\n\r\n   A1_Ratio_t = probTemp[2]/probTemp[1];       # A_1(t) / A_0(t);\r\n\r\n   A1_Ratio_0 = probTemp0[2]/probTemp0[1];     # A_1(0) / A_0(0); \r\n\r\n   A2_Ratio_t = probTemp[3] / probTemp[1];     #  = A_2(t)/A_0(t);\r\n\r\n   A2_Ratio_0 = probTemp0[3] / probTemp0[1];   #  = A_2(0) / A_0(0);\r\n\r\n   print(c(A2_Ratio_t, A2_Ratio_0, A1_Ratio_0, A1_Ratio_t));\r\n\r\n   break;\r\n\r\n   NFigure = 1000000;\r\n\r\n   x_Figure = rep(110, NFigure);\r\n\r\n   y_Figure = rep(110, NFigure);\r\n\r\n   xmax = -1000; xmin=1000;\r\n\r\n   imax = imin = 0;\r\n\r\n   pxt_found = 0.0;\r\n\r\n   x_Figure[1] = 0.0000001;\r\n\r\n   for(i in 2:NFigure)\r\n   {\r\n       x_Figure[i] = x_Figure[i-1] + 0.0000001;\r\n\r\n\r\n        NEH_Computed  = (1 - pH -x_Figure[i])*(A1_Ratio_t - A1_Ratio_0)*(1 - pH)/x_Figure[i];\r\n\r\n\t\r\n\r\n       if( NEH_Computed  >  Elements$nH)\r\n       {\r\n          #next;\r\n       }\r\n\r\n      # print(i);\r\n\r\n       y_Figure[i] = PxT_Formula(x_Figure[i], pH, A2_Ratio_t, A2_Ratio_0, A1_Ratio_0, A1_Ratio_t);\r\n\r\n#       if((x_Figure[i] > pxt - 0.03*pxt) && (x_Figure[i] < pxt + 0.1*pxt))\r\n       if((x_Figure[i] > pxt - 0.1*pxt) && (x_Figure[i] < pxt + 0.1*pxt))\r\n       {\r\n\r\n            print(c(x_Figure[i], y_Figure[i]));\r\n\r\n\t   if(x_Figure[i] > xmax)\r\n\t   {\r\n\t\txmax = x_Figure[i];\r\n\t\timax = i;\r\n\t   }\r\n\r\n\t   if(x_Figure[i] < xmin)\r\n\t   {\r\n\t        xmin = x_Figure[i];\r\n\t\timin = i;\r\n\t    }\r\n\r\n\r\n       }\r\n\r\n       if(i >= 2 && (y_Figure[i] < 0.0 && y_Figure[i-1] > 0.0) ||\r\n                 (y_Figure[i] > 0.0 && y_Figure[i-1] < 0.0) )\r\n       {\r\n            pxt_found = (x_Figure[i] + x_Figure[i-1])/2;\r\n\r\n\t    #x = uniroot(PxT_Formula, c(x_Figure[i-1], x_Figure[i+100]), tol = 10^(-17), pH = pH, A2_Ratio_t = A2_Ratio_t,\r\n   \t#\t\tA2_Ratio_0 = A2_Ratio_0,  A1_Ratio_0 = A1_Ratio_0, A1_Ratio_t = A1_Ratio_t);\r\n\r\n\t    #print(x);\r\n       }\r\n\r\n       #print(c(x, x1));\r\n   }\r\n\r\n   print(c(length(x_Figure), length(y_Figure), max(y_Figure)));\r\n   print(c(\"Found pxt = \", round(pxt_found, 7)));\r\n   plot(x_Figure[imin:imax], y_Figure[imin:imax], xlab=\"Percent Body Water Enrichment\",\r\n   ylab = \"Deviation from True Value\");\r\n#   lines(x_Figure[imin:imax], y_Figure[imin:imax], type=\"p\");\r\n   \r\n  # print(c(\"Value for \", pxt, x1));\r\n\r\n  # x = uniroot(PxT_Formula, c(0.0001, 0.1), tol = -10^(-9), pH = pH, NHtotal = Elements$nH, A2_Ratio_t = A2_Ratio_t,\r\n   #\t\t\tA2_Ratio_0 = A2_Ratio_0,  A1_Ratio_0 = A1_Ratio_0, A1_Ratio_t = A1_Ratio_t);\r\n\r\n  # print(probTemp);\r\n\r\n  # print(probTemp0);\r\n\r\n\r\n   print(summary(lm(y_Figure[imin:imax] ~ x_Figure[imin:imax])));\r\n\r\n   print(summary(lm(y_Figure[2:10000] ~ x_Figure[2:10000])));\r\n\r\n#   print(x);\r\n}\r\n\r\n#\r\n#\r\n#   Function to compute the pxt from A2(t)/A0(t), A2(0)/A0(0), A1(t)/A0(t) only\r\n#\r\n#   no NEH will be used, the NEH value is actually passed via a formula\r\n#\r\n#\r\n#\r\n\r\nPxT_Formula <- function(px_t, pH, A2_Ratio_t, A2_Ratio_0, A1_Ratio_0, A1_Ratio_t)\r\n{\r\n\r\n    NEH = (1 - pH - px_t)*(A1_Ratio_t - A1_Ratio_0)*(1 - pH)/px_t;\r\n#          (1 - pH - px_t)*(probTemp[2]/probTemp[1] - probTemp0[2]/probTemp0[1])*(1 - pH)/pxt;\r\n\r\n    #print(c(\"NEH1 \", NEH[[1]]));\r\n\r\n\r\n \r\n\r\n    f = -A2_Ratio_t + A2_Ratio_0 - A1_Ratio_0 * pH * NEH / (1 - pH);\r\n\r\n    f = f - ((px_t + pH)/(1 - pH - px_t))^2 * NEH * (NEH + 1) / 2;\r\n\r\n     f = f + (pH/(1 - pH))^2 * NEH * (NEH + 1)/2 ;\r\n\r\n     f = f + A1_Ratio_t * (px_t + pH) * (A1_Ratio_t - A1_Ratio_0)*(1 - pH)/px_t ;\r\n\r\n    f\r\n\r\n\r\n}\r\n\r\nPeptide_Pxt <- function(A2_Ratio_t, A2_Ratio_0, A1_Ratio_0, A1_Ratio_t, NEH)\r\n{\r\n   pH = 0.00015574 / (0.99984426 + 0.00015574);\r\n\r\n   NEH_predicted = 0;\r\n\r\n   pxt_predicted = 0.0;\r\n\r\n   NFigure = 10000;\r\n\r\n\r\n   x_Figure = rep(110, NFigure);\r\n\r\n   y_Figure = rep(110, NFigure);\r\n\r\n   pxt_found = 0.0; \r\n\r\n   beta_t = (A1_Ratio_t - A1_Ratio_0)/NEH\r\n\r\n   c_t    = (1 - pH) * beta_t / (1 + (1 - pH)*beta_t);\r\n\r\n   p_t    = (1 - pH) * c_t;\r\n\r\n   print(c(\"Pxt from NEH: \", p_t));\r\n\r\n   x_Figure[1] = 0.00001;\r\n\r\n   y_Figure[1] = PxT_Formula(x_Figure[1], pH, A2_Ratio_t, A2_Ratio_0, A1_Ratio_0, A1_Ratio_t);\r\n\r\n   for(i in 2:NFigure)\r\n   {\r\n       x_Figure[i] = x_Figure[i-1] + 0.00001;\r\n\r\n       y_Figure[i] = PxT_Formula(x_Figure[i], pH, A2_Ratio_t, A2_Ratio_0, A1_Ratio_0, A1_Ratio_t);\r\n\r\n       #print(c(\"i\", i));\r\n\r\n\r\n       NEH_temp = (1 - pH - x_Figure[i])*(A1_Ratio_t - A1_Ratio_0)*(1 - pH)/x_Figure[i];\r\n\r\n\r\n       if((y_Figure[i] < 0.0 && y_Figure[i-1] > 0.0) ||\r\n                 (y_Figure[i] > 0.0 && y_Figure[i-1] < 0.0) )\r\n       {\r\n            pxt_found = (x_Figure[i] + x_Figure[i-1])/2;\r\n\r\n\t    NEH_predicted = (1 - pH - x_Figure[i])*(A1_Ratio_t - A1_Ratio_0)*(1 - pH)/x_Figure[i];\r\n           print(c(\"px and NEH: \", pxt_found, NEH));\r\n       }\r\n\r\n       if(NEH_temp > NEH-1 && NEH_temp < NEH+1)\r\n       {\r\n            #  print(c(x_Figure[i], y_Figure[i]));\r\n       }\r\n   }\r\n\r\n   lines(x_Figure, y_Figure, type=\"p\");\r\n\r\n   print(c(\"pxt: NEH_predicted: \", pxt_found, NEH_predicted));\r\n\r\n   print(lm(y_Figure ~ x_Figure));\r\n\r\n\r\n   plot(x_Figure, y_Figure);\r\n}","type":"text"},{"name":"Labeling _duration_bounds.R","content":"source(\"Isotopes.R\")\r\n\r\nph <- 1.5574E-4\r\ngetLowerAndUpperLimits <- function(neh,\r\n                                   bwe,\r\n                                   maxLabelingDuration,\r\n                                   k,\r\n                                   peptideSequence,\r\n                                   delta_I0,\r\n                                   kt) {\r\n  # Initialize sequences for x and y\r\n  \r\n  I0_0 = Isotope_Distribution(peptideSequence)[1]\r\n  \r\n  ph <- 1.5574E-4\r\n  time <- seq(1, maxLabelingDuration, 1)\r\n  I0_asymp = I0_0 * (1 - bwe / (1 - ph))^neh\r\n  theo_ub = I0_0 - delta_I0\r\n  theo_lb = as.numeric((1 - kt) * I0_0 + kt * I0_asymp)\r\n  \r\n  \r\n  \r\n  # Initialize an empty dataframe to store the results with the correct column names\r\n  result_df <- data.frame(\r\n    time = integer(0),\r\n    theo_lb_values = numeric(0),\r\n    theo_ub_values = numeric(0),\r\n    lb = numeric(0),\r\n    ub = numeric(0),\r\n    InRange = logical(),\r\n    stringsAsFactors = FALSE\r\n  )\r\n  \r\n  numberOfDigits = 4\r\n  # Iterate over each value of x and y, computing their product and storing it in the dataframe\r\n  for (t_i in time) {\r\n    exp_lb = I0_asymp + (I0_0 - I0_asymp) * exp(-k * t_i)\r\n    exp_ub = I0_asymp + (I0_0 - I0_asymp) * exp(-k * t_i)\r\n    \r\n    \r\n    result_df <- rbind(\r\n      result_df,\r\n      data.frame(\r\n        time = as.integer(t_i),\r\n        theo_lb_values = format(theo_lb, digits = numberOfDigits) ,\r\n        theo_ub_values = format(theo_ub, digits = numberOfDigits) ,\r\n        lb = format(exp_lb, digits = numberOfDigits) ,\r\n        ub = format(exp_ub, digits = numberOfDigits) ,\r\n        InRange = (exp_lb >= theo_lb & exp_ub <= theo_ub)\r\n      )\r\n    )\r\n  }\r\n  \r\n  return (result_df)\r\n}\r\n\r\n\r\ngetLowerAndUpperLimits_Range <- function(neh,\r\n                                         bwe,\r\n                                         maxLabelingDuration,\r\n                                         k_low,\r\n                                         k_high,\r\n                                         peptideSequence,\r\n                                         delta_I0,\r\n                                         kt) {\r\n  # Initialize sequences for x and y\r\n  \r\n  I0_0 = Isotope_Distribution(peptideSequence)[1]\r\n  ph <- 1.5574E-4\r\n  time <- seq(1, maxLabelingDuration, 1)\r\n  I0_asymp = I0_0 * (1 - bwe / (1 - ph))^neh\r\n  theo_ub = I0_0 - delta_I0\r\n  theo_lb = as.numeric((1 - kt) * I0_0 + kt * I0_asymp)\r\n  \r\n  # Initialize an empty dataframe to store the results with the correct column names\r\n  result_df <- data.frame(\r\n    time = integer(0),\r\n    theo_lb_values = numeric(0),\r\n    theo_ub_values = numeric(0),\r\n    lb_low = numeric(0),\r\n    ub_low = numeric(0),\r\n    lb_upper = numeric(0),\r\n    ub_upper = numeric(0),\r\n    InRange_low = logical(),\r\n    InRange_upper = logical(),\r\n    stringsAsFactors = FALSE\r\n  )\r\n  \r\n  numberOfDigits = 4\r\n  # Iterate over each value of x and y, computing their product and storing it in the dataframe\r\n  for (t_i in time) {\r\n    I0_t_low_k = I0_asymp + (I0_0 - I0_asymp) * exp(-k_low * t_i)\r\n    I0_t_high_k = I0_asymp + (I0_0 - I0_asymp) * exp(-k_high * t_i)\r\n    \r\n    \r\n    result_df <- rbind(\r\n      result_df,\r\n      data.frame(\r\n        time = as.integer(t_i),\r\n        theo_lb_values = format(theo_lb, digits = numberOfDigits) ,\r\n        theo_ub_values = format(theo_ub, digits = numberOfDigits) ,\r\n        \r\n        \r\n        I0_t_low_k = format(I0_t_low_k, digits = numberOfDigits) ,\r\n        I0_t_high_k = format(I0_t_high_k, digits = numberOfDigits) ,\r\n        \r\n        \r\n        \r\n        InRange_low = (I0_t_low_k >= theo_lb &\r\n                         I0_t_low_k <= theo_ub),\r\n        InRange_upper = (I0_t_high_k >= theo_lb &\r\n                           I0_t_high_k <= theo_ub)\r\n        \r\n      )\r\n    )\r\n  }\r\n  \r\n  return (result_df)\r\n}\r\n","type":"text"},{"name":"Turnover rate estimation.Rproj","content":"Version: 1.0\r\nProjectId: f6fb261f-0b03-427d-a053-b86264c25283\r\n\r\nRestoreWorkspace: Default\r\nSaveWorkspace: Default\r\nAlwaysSaveHistory: Default\r\n\r\nEnableCodeIndexing: Yes\r\nUseSpacesForTab: Yes\r\nNumSpacesForTab: 2\r\nEncoding: UTF-8\r\n\r\nRnwWeave: Sweave\r\nLaTeX: pdfLaTeX\r\n","type":"text"},{"name":"init.R","content":"packages <- c(\"munsell\",\"ggplot2\", \"plotly\", \"dplyr\", \"bslib\", \"shiny\", \"shinythemes\",\"shinylive\",\"httr\")\r\n\r\n# Function to install and load packages\r\ninstall_and_load <- function(package) {\r\n  if (!requireNamespace(package, quietly = TRUE)) {\r\n    install.packages(package, character.only = TRUE, repos =\"http://cran.rstudio.com/\" ) #\"https://cloud.r-project.org\"\r\n  }\r\n  suppressMessages(library(package, character.only = TRUE))\r\n}\r\n\r\n\r\n# Install and load CRAN packages\r\ninvisible(lapply(packages, install_and_load))","type":"text"},{"name":"utils.R","content":"library(plotly)\r\nlibrary(dplyr)\r\nlibrary(tidyr)\r\n\r\n\r\n# Constants\r\npw <- 0.046\r\nph <- 1.5574e-4\r\n\r\n# Function to compute I0_t\r\n# inputs theoretical relative monoisotpe abundance: I0_0,\r\n# I0 value at the plateau of labeling:  I0_asymp, turnover rate:k, and labeling\r\n# duration:t\r\nget_I0_t <- function(I0_0, I0_asymp, k, t) {\r\n  return(I0_asymp + (I0_0 - I0_asymp) * exp(-k * t))\r\n}\r\n\r\n# Function to compute  relative monoisotpe abundance value at the plateau of\r\n# labeling inputs theoretical relative monoisotpe abundance: I0_0\r\n# and number of exchangeable hydrogens: neh\r\nget_I0_asymp <- function(I0_0, neh) {\r\n  return(I0_0 * ((1 - pw / (1 - ph))^neh))\r\n}\r\n\r\n# funtion to compute the numberof exchangable hydrogens for a given\r\n# peptide sequence\r\ngetNeh <- function(peptide) {\r\n  aa_neh = list(\r\n    \"A\" = 4   ,\r\n    \"C\" = 1.62,\r\n    \"D\" = 1.89,\r\n    \"E\" = 3.95,\r\n    \"F\" = 0.32,\r\n    \"G\" = 2.06,\r\n    \"H\" = 2.88,\r\n    \"I\" = 1   ,\r\n    \"K\" = 0.54,\r\n    \"L\" = 0.6 ,\r\n    \"M\" = 1.12,\r\n    \"N\" = 1.89,\r\n    \"P\" = 2.59,\r\n    \"Q\" = 3.95,\r\n    \"R\" = 3.43,\r\n    \"S\" = 2.61,\r\n    \"T\" = 0.2 ,\r\n    \"V\" = 0.56,\r\n    \"W\" = 0.08,\r\n    \"Y\" = 0.42\r\n  )\r\n  \r\n  \r\n  res = 0\r\n  for (aa in strsplit(peptide, \"\")[[1]]) {\r\n    res = res + as.numeric(aa_neh[as.character(aa)])\r\n  }\r\n  \r\n  return (res)\r\n  \r\n}\r\n\r\n# Function to create a plot showing experimental and theoretical I0 bounds \r\n# over time and recommended labeling duration\r\ngetPossibleRangePlot_plotly <- function(ans) {\r\n  \r\n  # Convert columns data type to numeric values\r\n  ans$time <- as.numeric(ans$time)\r\n  ans$lb <- as.numeric(ans$lb)\r\n  ans$ub <- as.numeric(ans$ub)\r\n  ans$theo_lb_values <- as.numeric(ans$theo_lb_values)\r\n  ans$theo_ub_values <- as.numeric(ans$theo_ub_values)\r\n  \r\n  # Reshape data for easier plotting\r\n  ans_long <- ans %>%\r\n    pivot_longer(\r\n      cols = c(lb, ub, theo_lb_values, theo_ub_values),\r\n      names_to = \"type\",\r\n      values_to = \"value\"\r\n    )\r\n  \r\n  # Identify region where theoretical values fall within experimental bounds\r\n  possibleRange <- ans %>% filter(InRange == TRUE)\r\n  min_time <- min(possibleRange$time) - 0.5\r\n  max_time <- max(possibleRange$time)\r\n  max_y <- max(possibleRange$theo_ub_values)\r\n  min_y <- min(possibleRange$theo_lb_values)\r\n  \r\n  # Define rectangle for visualizing valid I0 range area\r\n  rect_x <- c(min_time,\r\n              max_time + 2.5E-1,\r\n              max_time + 2.5E-1,\r\n              min_time,\r\n              min_time)\r\n  rect_y <- c(min_y, min_y, max_y, max_y, min_y)\r\n  \r\n  \r\n  #plot\r\n  p <- plot_ly(data = ans_long,\r\n               x = ~ time,\r\n               y = ~ value) %>%\r\n    \r\n    # green rectangle showing valid I0 region\r\n    add_trace(\r\n      x = rect_x,\r\n      y = rect_y,\r\n      fill = \"toself\",\r\n      fillcolor = \"green\",\r\n      opacity = 0.1,\r\n      line = list(color = \"rgba(0,0,0,0)\"),\r\n      type = \"scatter\",\r\n      mode = \"lines\",\r\n      showlegend = FALSE,\r\n      hoverinfo = \"none\",\r\n      inherit = FALSE\r\n    ) %>%\r\n    \r\n    # experimental I0(t) as black markers\r\n    add_trace(\r\n      data = subset(ans_long, type == \"lb\"),\r\n      type = \"scatter\",\r\n      mode = \"markers\",\r\n      marker = list(size = 8, color = \"black\"),\r\n      name = \" \",\r\n      # \"Lower bound (exp.)\",\r\n      showlegend = FALSE\r\n    ) %>%\r\n    \r\n    #theoretical lower bound as black dotted line\r\n    add_trace(\r\n      data = subset(ans_long, type == \"theo_lb_values\"),\r\n      type = \"scatter\",\r\n      mode = \"lines\",\r\n      line = list(dash = \"dot\", color = \"black\"),\r\n      name = \"Lower bound (theo.)\",\r\n      showlegend = TRUE\r\n    ) %>%\r\n    \r\n    # theoretical lower bound as red dotted line\r\n    add_trace(\r\n      data = subset(ans_long, type == \"theo_ub_values\"),\r\n      type = \"scatter\",\r\n      mode = \"lines\",\r\n      line = list(dash = \"dot\", color = \"red\"),\r\n      name = \"Upper bound (theo.)\",\r\n      showlegend = TRUE\r\n    ) %>%\r\n    \r\n    # Layout styling\r\n    layout(\r\n      title = \"\",\r\n      #Lower and Upper Bound Limits\",\r\n      xaxis = list(\r\n        title = \"Labeling Duration\",\r\n        gridcolor = \"white\",\r\n        zeroline = FALSE,\r\n        linecolor = \"black\",\r\n        showline = TRUE\r\n      ),\r\n      yaxis = list(\r\n        title = \"I<sub>0<\/sub>(t)\",\r\n        range = c(\r\n          min(ans$lb, ans$theo_lb_values) - 0.01,\r\n          max(ans$lb, ans$theo_ub_values) + 0.01\r\n        ),\r\n        gridcolor = \"white\",\r\n        zeroline = FALSE,\r\n        linecolor = \"black\",\r\n        showline = TRUE\r\n      ),\r\n      # legend = list(title = list(text = \"Legend\")),\r\n      legend = list(\r\n        x = 0.5,\r\n        # Moves legend to the top-left\r\n        y = 1,\r\n        # Aligns legend at the top\r\n        xanchor = \"left\",\r\n        yanchor = \"top\",\r\n        orientation = \"h\",\r\n        # Places legend items side by side\r\n        title = NULL  # Removes legend title\r\n      ),\r\n      plot_bgcolor = \"white\",\r\n      font = list(size = 14),\r\n      title = list(font = list(size = 14))\r\n    ) %>% # Updated titlefont syntax\r\n    \r\n    config(displayModeBar = FALSE)\r\n  \r\n  return(p)\r\n}\r\n\r\n\r\n# Function to create a plot showing experimental and theoretical I0 bounds \r\n# over time and recommended range of labeling durations\r\ngetPossibleRangePlot_plotly_range <- function(ans, klow, khigh) {\r\n  \r\n  # Convert columns data type to numeric values\r\n  ans$time <- as.numeric(ans$time)\r\n  ans$theo_lb_values <- as.numeric(ans$theo_lb_values)\r\n  ans$theo_ub_values <- as.numeric(ans$theo_ub_values)\r\n  ans$I0_t_low_k <- as.numeric(ans$I0_t_low_k)\r\n  ans$I0_t_high_k <- as.numeric(ans$I0_t_high_k)\r\n  \r\n  # Reshape data for easier plotting\r\n  ans_long <- ans %>%\r\n    pivot_longer(\r\n      cols = c(I0_t_low_k, I0_t_high_k, theo_lb_values, theo_ub_values),\r\n      names_to = \"type\",\r\n      values_to = \"value\"\r\n    )\r\n  \r\n  # Identify region where theoretical values fall within experimental bounds\r\n  possibleRange <- ans %>% filter(InRange_low == TRUE &\r\n                                    InRange_upper == TRUE)\r\n  min_time <- min(possibleRange$time) - 0.5\r\n  max_time <- max(possibleRange$time)\r\n  max_y <- max(possibleRange$theo_ub_values)\r\n  min_y <- min(possibleRange$theo_lb_values)\r\n   \r\n  \r\n  # Define rectangle for visualizing valid I0 range area\r\n  rect_x <- c(min_time,\r\n              max_time + 2.5E-1,\r\n              max_time + 2.5E-1,\r\n              min_time,\r\n              min_time)\r\n  rect_y <- c(min_y, min_y, max_y, max_y, min_y)\r\n  \r\n  #plot\r\n  p <- plot_ly(data = ans_long,\r\n               x = ~ time,\r\n               y = ~ value) %>%\r\n    \r\n    # green rectangle showing valid I0 region\r\n    add_trace(\r\n      x = rect_x,\r\n      y = rect_y,\r\n      fill = \"toself\",\r\n      fillcolor = \"green\",\r\n      opacity = 0.1,\r\n      line = list(color = \"rgba(0,0,0,0)\"),\r\n      type = \"scatter\",\r\n      mode = \"lines\",\r\n      showlegend = FALSE,\r\n      hoverinfo = \"none\",\r\n      inherit = FALSE\r\n    ) %>%\r\n    \r\n    # experimental I0(t) for small k as black markers\r\n    add_trace(\r\n      data = subset(ans_long, type == \"I0_t_low_k\"),\r\n      type = \"scatter\",\r\n      mode = \"markers\",\r\n      marker = list(size = 8, color = \"black\"),\r\n      name = paste(\"k=\", klow),\r\n      showlegend = TRUE\r\n    ) %>%\r\n    \r\n    # experimental I0(t) for large k as black markers\r\n    add_trace(\r\n      data = subset(ans_long, type == \"I0_t_high_k\"),\r\n      type = \"scatter\",\r\n      mode = \"markers\",\r\n      marker = list(size = 8, color = \"blue\"),\r\n      name = paste(\"k=\", khigh),\r\n      showlegend = TRUE\r\n    ) %>%\r\n    \r\n    #theoretical lower bound as black dotted line\r\n    add_trace(\r\n      data = subset(ans_long, type == \"theo_lb_values\"),\r\n      type = \"scatter\",\r\n      mode = \"lines\",\r\n      line = list(dash = \"dot\", color = \"black\"),\r\n      name = \"Lower bound (theo.)\",\r\n      showlegend = TRUE\r\n    ) %>%\r\n    \r\n    # theoretical lower bound as red dotted line\r\n    add_trace(\r\n      data = subset(ans_long, type == \"theo_ub_values\"),\r\n      type = \"scatter\",\r\n      mode = \"lines\",\r\n      line = list(dash = \"dot\", color = \"red\"),\r\n      name = \"Upper bound (theo.)\",\r\n      showlegend = TRUE\r\n    ) %>%\r\n    \r\n    # Layout styling\r\n    layout(\r\n      title = \"\",\r\n      #Lower and Upper Bound Limits\",\r\n      xaxis = list(\r\n        title = \"Labeling Duration\",\r\n        gridcolor = \"white\",\r\n        zeroline = FALSE,\r\n        linecolor = \"black\",\r\n        showline = TRUE\r\n      ),\r\n      yaxis = list(\r\n        title = \"I<sub>0<\/sub>(t)\",\r\n        range = c(\r\n          min(ans$I0_t_low_k, ans$I0_t_high_k) - 0.015,\r\n          max(ans$I0_t_low_k, ans$exp_lb_high) + 0.02\r\n        ),\r\n        gridcolor = \"white\",\r\n        zeroline = FALSE,\r\n        linecolor = \"black\",\r\n        showline = TRUE\r\n      ),\r\n      # legend = list(title = list(text = \"Legend\")),\r\n      legend = list(\r\n        x = 0.5,\r\n        # Moves legend to the top-left\r\n        y = 1,\r\n        # Aligns legend at the top\r\n        xanchor = \"left\",\r\n        yanchor = \"top\",\r\n        orientation = \"h\",\r\n        # Places legend items side by side\r\n        title = NULL  # Removes legend title\r\n      ),\r\n      plot_bgcolor = \"white\",\r\n      font = list(size = 14),\r\n      title = list(font = list(size = 14))\r\n    ) %>% # Updated titlefont syntax\r\n    \r\n    config(displayModeBar = FALSE)\r\n  \r\n  return(p)\r\n}\r\n\r\nsolve_for_kt_vals <- function(rd) {\r\n  relative_error <- function(x) {\r\n    if (x <= 0 || x >= 1)\r\n      return(Inf)  # Keep x,kt in (0, 1)\r\n    (-log(1 - x) - x) / x - rd\r\n  }\r\n  # Use uniroot within a safe interval\r\n  result <- tryCatch({\r\n    uniroot(relative_error,\r\n            interval = c(1e-6, 0.999),\r\n            tol = 1e-10)$root\r\n  }, error = function(e) {\r\n    NA  # Return NA if no root found\r\n  })\r\n\r\n  return(result)\r\n}\r\n","type":"text"}]
